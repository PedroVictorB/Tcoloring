<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Bootstrap Example</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

	</head>
	<body>
		<input type="file" id="files" name="files[]" webkitdirectory directory multiple>
		<input type="button" id="execute" name="execute" value="Executar">
		
		<script>
			class Vertex {
				constructor (id, colors) {
					this.id = id;
					this.color = -1;
					this.colors = colors;
					this.constraints = [];
				}
			};
			
			class Constraint {
				constructor (vertex, operator, value) {
					this.vertex = vertex;
					this.operator = operator;
					this.value = value;
				}
			}
			
			class InterferenceGraph {
			
				constructor () {
					this.vertices = [];
				}
			
				addVertex(id, colors) {
					var vertex = this.vertices.find(function(vertex){
						return vertex.id === id;
					});
					
					if(vertex === undefined) {
						var v = new Vertex(id, colors);
						this.vertices.push(v);
					}
				}
				
				addEdge(a, b, operator, value) {
					var va = this.vertices.find(function(vertex){
						return vertex.id === a;
					});
					var vb = this.vertices.find(function(vertex){
						return vertex.id === b;
					});
						
					if (va !== undefined && vb !== undefined) {
						var ca = new Constraint(vb, operator, value);
						va.constraints.push(ca);
						
						var cb = new Constraint(va, operator, value);
						vb.constraints.push(cb);
					}
				}
			};
			
			class GraphTheoryAlgorithms {
				welshPowell(graph) {
					graph.vertices.sort(function(a, b){
						return b.adj.length - a.adj.length;
					});
					
					var cn = 0
					
					for(var i = 0; i < graph.vertices.length; i++) {
						var found = false;
						var color = 1;
						
						while(color <= graph.vertices.length && !found) {
							var available = true;
							var j = 0;
							
							while(j < graph.vertices[i].adj.length && available) {
								if(graph.vertices[i].adj[j].color === color) {
									available = false;
								}
								else {
									j++;
								}
							}
							
							if(available) {
								found = true;
							}
							else {
								color++;
							}
						}
						
						if (found) {
							graph.vertices[i].color = color;
							if (color > cn) {
								cn = color;
							}
						}
					}
					
					return cn;
				}
				
				listColoring(graph, colors) {
					graph.vertices.sort(function(a, b){
						return b.adj.length - a.adj.length;
					});
					
					for(var i = 0; i < graph.vertices.length; i++) {
						var found = false;
						var j = 0;
						
						while(j < colors.length && !found) {
							var available = true;
							var k = 0;
							
							while(k < graph.vertices[i].adj.length && available) {
								if(graph.vertices[i].adj[k].color === colors[j]) {
									available = false;
								}
								else {
									k++;
								}
							}
							
							if(available) {
								found = true;
							}
							else {
								j++;
							}
						}
						
						if (found) {
							graph.vertices[i].color = colors[j];
						}
						else {
							return -1;
						}
					}
					
					return 1;
				}
				
				listColoringPerVertex(graph) {
					graph.vertices.sort(function(a, b){
						return b.adj.length - a.adj.length;
					});
					
					var cn = 0
					
					for(var i = 0; i < graph.vertices.length; i++) {
						var found = false;
						var j = 0;
						
						while(j < graph.vertices[i].colors.length && !found) {
							var available = true;
							var k = 0;
							
							while(k < graph.vertices[i].adj.length && available) {
								if(graph.vertices[i].adj[k].color === graph.vertices[i].colors[j]) {
									available = false;
								}
								else {
									k++;
								}
							}
							
							if(available) {
								found = true;
							}
							else {
								j++;
							}
						}
						
						if (found) {
							graph.vertices[i].color = graph.vertices[i].colors[j];
						}
						else {
							return -1;
						}
					}
					
					return 1;
				}
				
				tColoring(graph, t) {
					graph.vertices.sort(function(a, b){
						return b.adj.length - a.adj.length;
					});
					
					for(var i = 0; i < graph.vertices.length; i++) {
						var found = false;
						var color = 1;
						
						while(!found) {
							var available = true;
							var j = 0;
							
							while(j < graph.vertices[i].adj.length && available) {
								if(graph.vertices[i].adj[j].color !== -1) {
									var result = t.find(function(e){
										var x = graph.vertices[i].adj[j].color - color
										if(x < 0) {
											x = x * (-1);
										}
										return x === e;
									});
									
									if (result !== undefined) {
										available = false;
									}
									else {
										j++;
									}
								}
								else {
									j++;
								}
							}
							
							if(available) {
								found = true;
							}
							else {
								color++;
							}
						}
						
						if (found) {
							graph.vertices[i].color = color;
						}
						else {
							return -1;
						}
					}
					
					return 1;
				}
				
				tListColoringVariation(graph) {
					var teste = {a: 0, b: 0};
					
					graph.vertices.sort(function(a, b){
						return a.constraints.length - b.constraints.length;
					});
					
					for(var i = 0; i < graph.vertices.length; i++) {
						var found = false;
						var j = 0;
						
						while(j < graph.vertices[i].colors.length && !found) {
							var available = true;
							var k = 0;
							
							while(k < graph.vertices[i].constraints.length && available) {
								//console.log("Vertice:" + graph.vertices[i].id + " | Cor: " + graph.vertices[i].colors[j]);
								if (graph.vertices[i].constraints[k].vertex.color != -1) {
									var operator = graph.vertices[i].constraints[k].operator;
									var value = graph.vertices[i].constraints[k].value;
									var difference = graph.vertices[i].colors[j] - graph.vertices[i].constraints[k].vertex.color;
									if (difference < 0) {
										difference = difference * (-1);
									}
							
									if (operator == '>') {
										if (difference <= value) {
											available = false;
										}
										else {
											k++;
										}
									}
									else {
										if (difference != value) {
											available = false;
										}
										else {
											k++;
										}
									}
								}
								else {
									k++;
								}
							}
							
							if(available) {
								found = true;
							}
							else {
								j++;
							}
						}
						
						if (found) {
							graph.vertices[i].color = graph.vertices[i].colors[j];
							console.log("VEIO: " + graph.vertices[i].id + "(" + graph.vertices[i].color + ")");
						}
						else {
							return -1;
						}
					}
					
					return 1;
				}
			}
			
			function handleFileSelect(evt) {
				readGraph(evt.target.files);
			}
			
			function handleExecuteClick(evt) {
				if(document.getElementById('files').value) {
					makerInterferenceGraph();
					
					var graphTheoryAlgorithms = new GraphTheoryAlgorithms();
					var result = graphTheoryAlgorithms.tListColoringVariation(graph);
					console.log(result);
				}
				else {
					alert("Selecione uma instÃ¢ncia!");
				}
			}
			
			function readGraph(files) {
				for (var i = 0; i < files.length; i++) {
					var file = files[i];
					
					if (file.name === "VAR.TXT" || file.name === "var.txt") {
						readVARFile(file);
					}
					else if (file.name === "DOM.TXT" || file.name === "dom.txt") {
						readDOMFile(file);
					}
					else {
						if (file.name === "CTR.TXT" || file.name === "ctr.txt") {
							readCTRFile(file);
						}
					}
				}
			}
			
			function readVARFile(file) {
				var reader = new FileReader();
				reader.onload = (function(file) {
					return function(e) {
						var contents = e.target.result;
						var lines = contents.split('\n');
						
						var verticesAndDomains = [];
						for (var line = 0; line < lines.length; line++) {
							var temp = lines[line].trim().split(/\ +/);
							if (temp[0]) {
								verticesAndDomains.push({id: parseInt(temp[0]), domain: parseInt(temp[1])});
							}
						}
						
						VARContent = verticesAndDomains;
					};
				})(file);
				reader.readAsText(file);
			}
			
			function readDOMFile(file) {
				var reader = new FileReader();
				reader.onload = (function(file) {
					return function(e) {
						var contents = e.target.result;
						var lines = contents.split('\n');
						
						var domains = [];
						for (var line = 1; line < lines.length; line++) {
							var temp = lines[line].trim().split(/\ +/);
							if (temp[0]) {
								var domain = {id: parseInt(temp[0]), frequencies: []}
								for(var i = 2; i < parseInt(temp[1]) + 2; i++) {
									domain.frequencies.push(parseInt(temp[i]));
								}
								domains.push(domain);
							}
						}
						
						DOMContent = domains;
					};
				})(file);
				reader.readAsText(file);
			}
			
			function readCTRFile(file) {
				var reader = new FileReader();
				reader.onload = (function(file) {
					return function(e) {
						var contents = e.target.result;
						var lines = contents.split('\n');
						
						var constraints = [];
						for (var line = 0; line < lines.length; line++) {
							var temp = lines[line].trim().split(/\ +/);
							if (temp[0]) {
								constraints.push({a: parseInt(temp[0]), b: parseInt(temp[1]), operator: temp[3], value: parseInt(temp[4])});
							}
						}
						
						CTRContent = constraints;
					};
				})(file);
				reader.readAsText(file);
			}
			
			function makerInterferenceGraph()
			{
				graph = new InterferenceGraph();
				
				for(var i = 0; i < VARContent.length; i++) {
					graph.addVertex(VARContent[i].id, DOMContent[VARContent[i].domain-1].frequencies);
				}
				
				for(var i = 0; i < CTRContent.length; i++) {
					graph.addEdge(CTRContent[i].a, CTRContent[i].b, CTRContent[i].operator, CTRContent[i].value);
				}
			}
			
			document.getElementById('files').addEventListener('change', handleFileSelect, false);
			document.getElementById('execute').addEventListener('click', handleExecuteClick, false);
			
			var graph = new InterferenceGraph();
			var VARContent;
			var DOMContent;
			var CTRContent;	
		</script>
	</body>
</html>
